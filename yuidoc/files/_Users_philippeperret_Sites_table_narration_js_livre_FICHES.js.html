<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/Users/philippeperret/Sites/table_narration/js/livre/FICHES.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/App.html">App</a></li>
            
                <li><a href="../classes/Collection.html">Collection</a></li>
            
                <li><a href="../classes/ColText.html">ColText</a></li>
            
                <li><a href="../classes/ContextualHelp.html">ContextualHelp</a></li>
            
                <li><a href="../classes/DICO.html">DICO</a></li>
            
                <li><a href="../classes/Fiche.html">Fiche</a></li>
            
                <li><a href="../classes/FICHES.html">FICHES</a></li>
            
                <li><a href="../classes/FILMS.html">FILMS</a></li>
            
                <li><a href="../classes/Mot.html">Mot</a></li>
            
                <li><a href="../classes/ObjetClass.html">ObjetClass</a></li>
            
                <li><a href="../classes/OBJETS.html">OBJETS</a></li>
            
                <li><a href="../classes/PARAGRAPHES.html">PARAGRAPHES</a></li>
            
                <li><a href="../classes/UI.html">UI</a></li>
            
                <li><a href="../classes/UI.Input.html">UI.Input</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/App.js.html">App.js</a></li>
            
                <li><a href="../modules/Collection.html">Collection</a></li>
            
                <li><a href="../modules/ColText.html">ColText</a></li>
            
                <li><a href="../modules/ContextualHelp.html">ContextualHelp</a></li>
            
                <li><a href="../modules/Data.html">Data</a></li>
            
                <li><a href="../modules/data.html">data</a></li>
            
                <li><a href="../modules/Debug.html">Debug</a></li>
            
                <li><a href="../modules/DICO.html">DICO</a></li>
            
                <li><a href="../modules/DICO.js.html">DICO.js</a></li>
            
                <li><a href="../modules/dom.html">dom</a></li>
            
                <li><a href="../modules/Dom.html">Dom</a></li>
            
                <li><a href="../modules/Edition.html">Edition</a></li>
            
                <li><a href="../modules/fiche.dom.html">fiche.dom</a></li>
            
                <li><a href="../modules/FicheClass.html">FicheClass</a></li>
            
                <li><a href="../modules/FICHES.html">FICHES</a></li>
            
                <li><a href="../modules/FilmClass.html">FilmClass</a></li>
            
                <li><a href="../modules/FILMS.html">FILMS</a></li>
            
                <li><a href="../modules/HandyMethods.html">HandyMethods</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/jQueryExtension.html">jQueryExtension</a></li>
            
                <li><a href="../modules/KeyboardEvents.html">KeyboardEvents</a></li>
            
                <li><a href="../modules/KeyEvents.html">KeyEvents</a></li>
            
                <li><a href="../modules/Mot.html">Mot</a></li>
            
                <li><a href="../modules/ObjetClass.html">ObjetClass</a></li>
            
                <li><a href="../modules/OBJETS.html">OBJETS</a></li>
            
                <li><a href="../modules/PARAGRAPHS.html">PARAGRAPHS</a></li>
            
                <li><a href="../modules/ready.js.html">ready.js</a></li>
            
                <li><a href="../modules/String.html">String</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: /Users/philippeperret/Sites/table_narration/js/livre/FICHES.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
  * @module FICHES
  *
  */
// Raccourci
window.get_fiche = function(id)
{
  return FICHES.get(id)
}

/**
  * Objet FICHES
  * ------------
  * Pour la gestion des fiches comme ensemble.
  *
  * @class  FICHES
  * @static
  *
  */
window.FICHES = {
  
  /**
    * Données pour les types de fiche
    *  
    * @property datatype
    * @type     {Object}
    * @static
    * @final
    */
  datatype:{
    &#x27;para&#x27;  : {level: 5 , defvalue: &quot;&quot;,                 child_type:null,    parent_type:&#x27;page&#x27;, hname:&quot;paragraphe&quot;},
    &#x27;page&#x27;  : {level: 10, defvalue: &quot;TITRE_PAGE&quot;,       child_type:&#x27;para&#x27;,  parent_type:&#x27;chap&#x27;, hname: &quot;page&quot;},
    &#x27;chap&#x27;  : {level: 15, defvalue: &quot;TITRE_CHAPITRE&quot;,   child_type:&#x27;page&#x27;,  parent_type:&#x27;book&#x27;, hname: &quot;chapitre&quot;},
    &#x27;book&#x27;  : {level: 20, defvalue: &quot;TITRE_LIVRE&quot;,      child_type:&#x27;chap&#x27;,  parent_type:null,   hname: &quot;livre&quot;}
    },

  /*
   *  PROPRIÉTÉS GÉNÉRALES
   *  
   */
  last_id: -1,
  
  /**
    *  Table des fiches instanciées
    *  ----------------------------
    *
    * NOTES
    * -----
    *   * En clé, l&#x27;identifiant ({Number}), en valeur l&#x27;instance de la fiche
    *   * C&#x27;est la méthode &#x60;create&#x27; de la fiche qui la met dans la liste
    *   * Utiliser la méthode &#x60;FICHES.get&#x27; pour obtenir une fiche de cette liste.
    *
    * @property {Object} list
    *
    */
  list:{},
  
  /*
   *  Nombre de fiches dans &#x60;list&#x27;
   */
  length:0,
  
  /*
   *  {Hash} des fiches sélectionnées
   *  
   *  En clé, l&#x27;ID de la fiche, en valeur, son instance
   */
  selecteds:{},
  
  /*
   *  Fiche courante (instance Fiche)
   *  
   */
  current:null,

  /*
   *  Indique si on se trouve dans un champ de saisie (input-text ou textarea)
   *  de la fiche courante.
   *  (Mais c&#x27;est une propriété complexe qui empêche d&#x27;enregistrer le livre
   *   pendant l&#x27;édition)
   *
   *  @value    NULL si aucun text-field, ou un set jQuery
   */
  // current_text_field:false,
  
  /*
   *  Retourne la fiche ({Fiche&gt;something}) d&#x27;identifiant +id+
   *  
   */
  get:function(id)
  {
    if(undefined==id) throw &quot;Il faut fournir l&#x27;identifiant de la fiche à retourner&quot;;
    var fi = this.list[id]
    if(undefined==fi) throw &quot;La fiche d&#x27;identifiant #&quot;+id+&quot; est inconnue au bataillon&quot;;
    return fi
  },
  
  /**
    *  Reçoit un objet DOM de fiche (class fiche) et
    *  retourne la fiche correspondante.
    *
    * @param  obj {HTMLDom|jQuerySet} Element Dom appartenant à une fiche ou l&#x27;objet
    *             (tag:fiche) de la fiche elle-même.
    * @return {Fiche} L&#x27;instance Fiche ({Book}, {Chapter} etc) de la fiche propriétaire
    *         de ce DOM Element.
    *
    */
  domObj_to_fiche:function(obj)
  {
    var fi = this.list[ $(obj).attr(&#x27;id&#x27;).split(&#x27;-&#x27;)[1] ]
    if(undefined == fi) throw LOCALE.fiche.error[&#x27;no fiche for dom obj&#x27;]
    else return fi
  },
  
  /*
   *  Ajoute une fiche instanciée
   *  
   *  NOTE
   *  ----
   *    # Si la fiche existe déjà, on ne l&#x27;ajoute pas.
   *
   *  @param  ifiche    Instance Fiche de la fiche instanciée
   *
   */
  add:function(ifiche)
  {
    if(undefined != this.list[ifiche.id]) return
    this.list[ifiche.id] = ifiche
    this.length ++
  },
  
  /*
   *  Supprime une fiche instanciée
   *  
   *  NOTES
   *  -----
   *  # C&#x27;est cette méthode qui doit être appelée, pas la propriété &#x60;delete&#x27; de la fiche 
   *
   *  # Mais dans le processus normal, on appelle &#x27;&lt;fiche&gt;.want_delete&#x27; qui demande confirmation
   *    de la suppression en demandant aussi si les enfants doivent être supprimés avec la fiche,
   *    ou être gardés.
   *
   *  # La fenêtre de confirmation demande aussi si les enfants doivent être détruits,
   *    ce qui se fera de façon récursive (resultat.kill_children). Si les enfants
   *    ne doivent pas être détruits, on les sort simplement de leur parent.
   *
   */
  remove:function(ifiche, resultat)
  {
    var idm = &quot;FICHES.remove&quot;
    dlog(&quot;---&gt; &quot;+idm)
    var detruire_enfants = resultat.kill_children == true
    
    
    // La fiche doit exister
    if(undefined == this.list[ifiche.id]) return
    var ifiche = this.list[ifiche.id]
    var enfants = ifiche.enfants
    ifiche.delete
    if(this.current.id == ifiche.id) this.current = null
    delete this.list[ifiche.id]
    this.length -- ;
    // Si la fiche a un parent
    if(ifiche.parent)
    {
      ifiche.parent.remove_child( ifiche )
    }
    // Si la fiche a des enfants
    if(enfants)
    {
      if (detruire_enfants)
      {
        L(enfants).each(function(ichild){FICHES.remove(ichild,{kill_children:true})})
      }
      else
      {
        L(enfants).each(function(ichild){
          if(ichild.ranged) ichild.unrange
          ichild.parent   = null ; 
          ichild.modified = true ;
        })
      }
    }
    dlog(&quot;&lt;- &quot;+idm)
  },
  
  /*
   *  Ajout d&#x27;une fiche à la sélection
   *  
   *  NOTES
   *  -----
   *    * Dans tous les cas, la dernière fiche est mise en fiche courante
   *
   *  @param  ifiche    Instance de la fiche à ajouter à la sélection
   *  @param  keep      Si TRUE, on doit garder les sélections courantes
   *                    FALSE par défaut, vrai quand la touche majuscule est
   *                    appuyée.
   */
  add_selected:function(ifiche, keep)
  {
    // console.log(&quot;---&gt; add_selected (ifiche #&quot;+ifiche.id+&quot;)&quot;)
    if(undefined == keep) keep = false
    if(this.current == ifiche) return
    if(this.current &amp;&amp; !keep) this.current.deselect
    this.current = ifiche
    if (undefined != this.selecteds[ifiche.id]) return
    
    this.selecteds[ifiche.id] = ifiche
    // Réglage de la captation des touches clavier
    window.onkeypress = keypress_when_fiche_selected_out_textfield
  },
  
  /*
   *  Sauvegarde de toutes les fiches marquées modifiées
   *  
   */
  saving:false,
  save:function(poursuivre)
  {
    this.saving = true
    this.poursuivre_save = poursuivre
    var fiches = []
    for(var i in Collection.modifieds_list)
    {
      fiches.push(Collection.modifieds_list[i].data)
    }
    Ajax.send({script:&#x27;fiche/save&#x27;, fiches:fiches}, $.proxy(this.retour_save,this))
  },
  retour_save:function(rajax)
  {
    if(rajax.ok)
    {
      // Si toutes les fiches ont pu être sauvées, on les marque non
      // modifiées
      for(var i in Collection.modifieds_list)
      {
        Collection.modifieds_list[i].modified = false
      }
      delete Collection.modifieds_list
    }
    else
    {
      F.error(rajax.message)
    }
    this.saving = false
    if(&#x27;function&#x27; == typeof this.poursuivre_save) this.poursuivre_save()
  },
  
  
  /**
    *  Dispatch des fiches
    *
    *  NOTES
    *  -----
    *    = Avec le nouveau fonctionnement, il n&#x27;y a plus de problème au niveau
    *      des parents ou des enfants. Les fiches sont instanciées à leur première
    *      détection (soit ici, soit dans les enfants/parent des fiches traitées),
    *      puis elles sont ensuites &quot;remplies&quot; avec les données si la fiche est
    *      traitées plus tard ici.
    *
    *    = Par défaut, les fiches sont maintenant créées fermées, donc on doit
    *      passer seulement en revue les fiches qui doivent être ouvertes.
    *
    *    = Pour le moment, cette méthode n&#x27;est appelée qu&#x27;au chargement de la
    *      collection. Mais à l&#x27;avenir on pourra imaginer qu&#x27;elle soit aussi
    *      utilisée en cas de chargement en masse de fiches. Il faut donc en
    *      tenir compte et utiliser la propriété &#x60;Collected.loaded&#x27; pour savoir
    *      si c&#x27;est un tout premier chargement.
    *
    *  PRODUIT
    *  -------
    *    = La création de la fiche (toujours, entendu qu&#x27;une fiche passant par
    *      ce dispatch a forcément toutes ses données)
    *
    *    = La tenue à jour de &#x60;Collection.books&#x27;
    *
    * @method dispatch
    * @param  data   {Array} Liste des fiches remontées par &#x60;Collection.load.data&#x60;
    *
    */
  dispatch:function( data )
  {
    dlog(&quot;---&gt; FICHES.dispatch&quot;, DB_FCT_ENTER)
    var i = 0, dfiche, ifiche ;
    var first_loading = Collection.loaded == false
    var nombre_fiches = data.length
    var instances = []

    if(first_loading)
    {
      Collection.books = []
    }
    
    // Création des instances de toutes les fiches utiles
    // (même les enfants cachés)
    for( ; i &lt; nombre_fiches; ++i)
    {
      ifiche = this.fiche_from( data[i] )
      ifiche.loaded = true // Une fiche passant par ici est forcément chargée
      instances.push( ifiche )
    }

    // Création des fiches sur la table
    L(instances).each(function(instance){
      instance.create
    })
    
    // Rangement des enfants (toujours)
    L(instances).each(function(instance){
      if(instance.has_parent) instance.range
                         else instance.positionne
    })
    
    // Réglage de l&#x27;indice des fiches enfants
    L(instances).each(function(instance){
      if(instance.has_children) instance.update_indice_enfants()
    })
    
    
    dlog(&quot;&lt;- FICHES.dispatch&quot;, DB_FCT_ENTER)
  },
    
  /*
   *  Bascule entre l&#x27;ouverture et la fermeture les fiches
   *  dans +arr+
   *  
   *  @param  arr   {Array} d&#x27;instances de fiche ou simple fiche
   *  @param  evt   Event ayant conduit à l&#x27;appel de cette méthode
   */
  toggle:function(arr, evt)
  {
    dlog(&quot;=&gt; FICHES.toggle&quot;)
    if(undefined != arr.opened) arr = [arr]
    this[arr[0].opened ? &#x27;close&#x27; : &#x27;open&#x27;](arr)
  },
  
  /*
   *  Ouvre la ou les fiches données en argument
   *
   * @param arr   Liste d&#x27;instance Fiche ou Instance Fiche
   */
  open:function(arr)
  {
    if(exact_typeof(arr) != &#x27;array&#x27;) arr = [arr] ;
    L(arr).each(function(fi){ if(fi.built) fi.open })
  },
  /*
   *  Ferme la ou les fiches données en argument
   *  
   * @param arr   Liste d&#x27;instance Fiche ou Instance Fiche
   *
   */
  close:function(arr)
  {
    if(exact_typeof(arr) != &#x27;array&#x27;) arr = [arr] ;
    L(arr).each(function(fi){ fi.close })
  },
  /*
   *  Charge les fiches données en arguments
   *
   *  @param  fiches    Liste {Array} de {Hash} contenant &#x60;id&#x27; et &#x60;type&#x27;  
   *
   *  La méthode appelante doit définir &#x60;FICHES.after_load.poursuivre&#x27;
   *  Soit une function normale ({Function}) soit un {Object} contenant
   *  {id:&lt;id fiche&gt;, prop:&lt;propriété complexe} (p.e. {id:12, prop:&#x27;open&#x27;})
   *
   */
  load:function(arr)
  {
    dlog(&quot;---&gt; FICHES.load&quot;, DB_FCT_ENTER)
    Ajax.send(
      {script:&#x27;fiche/load&#x27;, fiches:arr},
      $.proxy(this.after_load, this)
    )
    dlog(&quot;&lt;- FICHES.load&quot;, DB_FCT_ENTER)
  },
  /* Retour de la précédente */
  after_load:function(rajax)
  {
    dlog(&quot;---&gt; FICHES.after_load&quot;, DB_FCT_ENTER)
    if(rajax.ok)
    {
      // On dispatch les fiches remontées
      this.dispatch( rajax.fiches )
      // Méthode ou propriété complexe pour suivre
      // @RAPPEL: Si c&#x27;est une propriété complexe qui doit être appelée,
      //          this.after_load.poursuivre est mis à {id:&lt;ID de la fiche visée&gt;, 
      //          prop:&lt;propriété&gt;}
      var fn = this.after_load.poursuivre
      if(     &#x27;function&#x27;== typeof fn) fn()
      else if(&#x27;object&#x27;  == typeof fn) this.get(fn.id)[fn.prop]
    }
    else F.error(rajax.message)
    dlog(&quot;&lt;- FICHES.after_load&quot;, DB_FCT_ENTER)
  },
  /*
   *  Range la ou les fiches données en argument
   *  
   */
  range:function(arr)
  {
    dlog(&quot;---&gt; FICHES.range&quot;, DB_FCT_ENTER)
    if(exact_typeof(arr) != &#x27;array&#x27;) arr = [arr] ;
    L(arr).each(function(fi){ if(fi.built) fi.range })
    dlog(&quot;&lt;- FICHES.range&quot;, DB_FCT_ENTER)
  },
  
  /*
   *  Retourne la fiche (ou LES fiches) correspondant à l&#x27;objet
   *  +obj+ envoyé, contenant :
   *    - soit &#x27;id&#x27; et &#x27;type&#x27;
   *    - soit une liste d&#x27;objets contenant &#x27;id&#x27; et &#x27;type&#x27;
   *  La méthode crée les fiches si nécessaire, en fonction de leur type
   *  ou renvoie les fiches déjà créées.
   *  
   */
  fiche:function(obj)
  {
    var i=0, list=[];
    var is_list = &#x27;array&#x27; == exact_typeof(obj) ;
    if(!is_list) obj = [obj]
    for(len = obj.length; i&lt;len; ++i) list.push( this.fiche_from( obj[i] ))
    return is_list ?  list : list[0]
  },

  /*
   *  Renvoie la fiche si elle existe ou la crée (entièrement)
   *
   *  NOTES
   *  -----
   *
   *  # La méthode est identique à la précédente mais ne peut recevoir les données
   *    que d&#x27;une seule fiche.
   *
   *  # 2 # Les données +data+ sont dispatchées dans la fiche, même lorsqu&#x27;elle
   *    existe, sauf si son &#x60;loaded&#x60; est à true. Cela est utile au chargement : si un 
   *    parent pas encore créé est défini dans une fiche, on le crée &quot;rapidement&quot; 
   *    (simplement avec son id et son type) puis ensuite, quand on traite le parent dans
   *    le chargement, on n&#x27;a plus qu&#x27;à dispatcher toutes ses données.
   *
   *  @return L&#x27;instance Fiche
   *  
   */
  fiche_from:function(data)
  {
    dlog(&quot;---&gt; FICHES.fiche_from&quot;, DB_FCT_ENTER)
    var idm=&quot;[FICHES.fiche_from] &quot;, ifiche ;
    if(undefined != this.list[data.id]){ 
      // =&gt; L&#x27;instance existe déjà
      ifiche = this.list[data.id]
      if(!ifiche.loaded) ifiche.dispatch( data ) // cf. note #2 ci-dessus
    }
    else
    { 
      // =&gt; il faut créer une instance      
      ifiche = this.create_instance_fiche_of_type(data)
    }
    dlog(&quot;&lt;- FICHES.fiche_from&quot;, DB_FCT_ENTER)
    return ifiche
  },
  // @data  Peut contenir &#x27;id&#x27; et &#x27;type&#x27; au minimum
  create_instance_fiche_of_type:function(data)
  {
    dlog(&quot;---&gt; FICHES.create_instance_fiche_of_type [&quot;+data.type+&quot;#&quot;+data.id+&quot;]&quot;, DB_FCT_ENTER)
    switch(data.type)
    {
    case &#x27;book&#x27; : return new Book(data)
    case &#x27;chap&#x27; : return new Chapter(data)
    case &#x27;page&#x27; : return new Page(data)
    case &#x27;para&#x27; : return new Paragraph(data)
    }
  },
  
  /*
   *  Crée entièrement une nouvelle fiche à partir des +data+
   *  transmises.
   *
   *  NOTES
   *  -----
   *    @ Il s&#x27;agit d&#x27;une toute nouvelle fiche, jamais d&#x27;une fiche
   *      existente.
   *    @ Pour le moment, la fiche n&#x27;est pas marquée modifiée.
   *  
   *  @param  data    {Hash} Les données pour la nouvelle fiche
   *  @param  options {Hash} Les options.
   *                    focus_titre   Si TRUE, on passe le titre en édition
   *                    focus_texte   Si TRUE, on passe le texte en édition (même chose que pour
   *                                  focus_titre, mais pour un paragraphe)
   *                    select        Si TRUE, on sélectionne la fiche
   *                    after_fiche   Si défini, c&#x27;est la fiche après laquelle on doit
   *                                  placer la nouvelle fiche.
   *                    before_fiche  Idem, mais en fournissant la fiche après.
   *
   *  @return La nouvelle fiche créée
   */
  full_create:function(data, options)
  {
    dlog(&quot;---&gt; FICHES.full_create&quot;, DB_FCT_ENTER)
    var ifiche = FICHES.create_instance_fiche_of_type(data)
    ifiche.create
    if(options)
    {
      // La fiche a été créée à la fin de son parent, il faut la placer
      // à un autre endroit.
      if(options.after_fiche)
      {
        ifiche.set_after( options.after_fiche )
      }
      else if (options.before_fiche)
      {
        ifiche.set_before( options.before_fiche )
      }
      
      if(options.focus_titre)
      {
        ifiche.enable_main_field
      }
      else if(options.select)
      {
        ifiche.select
      }
    }
    dlog(&quot;&lt;- FICHES.full_create&quot;, DB_FCT_ENTER)
    return ifiche
  },
  
  /*
   *  Suppression d&#x27;une fiche de la sélection
   *  
   *  @param  ifiche    Instance de la fiche à retirer de la sélection
   */
  remove_selected:function(ifiche)
  {
    var idm = &quot;FICHES.remove_selected(ifiche:&quot;+ifiche.type_id+&quot;)&quot;
    dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER)
    if(this.current == ifiche) this.current = null
    delete this.selecteds[ifiche.id]
    dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER)
  },

  /*
   *  Gestionnaire de l&#x27;évènement CLICK sur le titre/texte
   *  
   */
  on_click_on_main_field:function(ifiche, evt)
  {
    // dlog(&quot;Click sur le titre/texte&quot;)
    ifiche.toggle_select(evt) // stop l&#x27;event
    if(evt.metaKey)
    {
      ifiche.enable_main_field
    }
    return false
  },
  /*
   *  Retourne true si le champ d&#x27;édition courant et celui
   *  donné en argument
   *  
   *  @param  obj   DOM Element jQuery
   *
   */
  current_field_is:function(obj)
  {
    if( ! this.current_text_field ) return false
    return this.current_text_field[0].id == $(obj)[0].id
  },
  
  // /*
  //  *  Méthode appelée quand on focuse/blure dans n&#x27;importe quel champ de
  //  *  saisie de la fiche
  //  *  
  //  */
  // onfocus_textfield:function(ifiche, evt)
  // {
  //   /*
  //   - on sélectionne la fiche
  //   - on change l&#x27;aspect du champ (&#x27;focused&#x27;)
  //   - on sélectionne son texte
  //   - on met le champ courant à ce champ (current_text_field)
  //   - on change de gestion d&#x27;évènement keypress
  //   - on bloque les click sur le champ
  //    */
  //   console.warn(&quot;La méthode FICHES.onfocus_textfield doit devenir obsolète&quot;)
  //   var idm = &quot;FICHES.onfocus_textfield(ifiche:&quot;+ifiche.type_id+&quot;)&quot;
  //   dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER | DB_CURRENT)
  //   ifiche.select
  //   var target = $(evt.currentTarget)
  //   target.addClass(&#x27;focused&#x27;)
  //   target.select()
  //   this.current_text_field = target // complex
  //   window.onkeypress = window.keypress_when_fiche_selected_in_textfield
  //   // On bloque les click dans le champ (pour empêcher la déselection
  //   // qui remet le onkeypress à rien)
  //   this.current_text_field.bind(&#x27;click&#x27;, function(evt){evt.stopPropagation();return true})
  //   dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER | DB_CURRENT)
  // },
  // onblur_textfield:function(ifiche, evt)
  // {
  //   console.warn(&quot;La méthode FICHES.onblur_textfield doit devenir obsolète&quot;)
  //   var idm = &quot;FICHES.onblur_textfield(ifiche:&quot;+ifiche.type_id+&quot;)&quot;
  //   dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER | DB_CURRENT)
  //   $(evt.target).removeClass(&#x27;focused&#x27;)
  //   if(this.current_field_is(ifiche.main_field)) ifiche.disable_main_field
  //   if(this.current) window.onkeypress = keypress_when_fiche_selected_out_textfield
  //   else window.onkeypress = keypress_when_no_selection_no_edition
  //   this.current_text_field.unbind(&#x27;click&#x27;, function(evt){evt.stopPropagation();return true})
  //   this.current_text_field = null // complex
  //   dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER)
  // },
  
  /*
   *  Méthode qui change la sélection courante
   *  ----------------------------------------
   *
   *  NOTES
   *  -----
   *    ::  Cette méthode permet de forcer le changement du texte, 
   *        qui dans le cas contraire ne génère pas de onchange quand on
   *        bouge la sélection.
   *  
   */
  set_selection_to:function(new_value)
  {
    Selection.set(FICHES.current_text_field, new_value,{end:true})
    if(this.current_field_is(this.current.main_field)) 
    {
      FICHES.current.onchange_titre_or_texte(FICHES.current_text_field.val())
    }
  }
}

Object.defineProperties(FICHES,{
  &quot;init_all&quot;:{
    get:function(){
      this.length     = 0
      this.list       = {}
      this.current    = null
      this.last_id    = -1
      this.selecteds  = {}
      $(&#x27;section#table&#x27;).html(&#x27;&#x27;)
    }
  },
  
  &quot;current_text_field&quot;:{
    get:function(){ return this._current_text_field || false },
    /*
     *  Définit le text field courant (ou rien)
     *  
     *  @param  obj   Soit l&#x27;objet jQuery du text-field, soit NULL quand
     *                on en sort.
     */
    set:function(obj)
    {
      var editing = ( obj !== null )
      this._current_text_field = obj
      Collection[editing ? &#x27;disable_save&#x27; : &#x27;enable_save&#x27;]
    }
  }
  
})

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
