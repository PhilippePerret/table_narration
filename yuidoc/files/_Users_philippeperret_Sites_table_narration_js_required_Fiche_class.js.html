<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>/Users/philippeperret/Sites/table_narration/js/required/Fiche_class.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/App.html">App</a></li>
            
                <li><a href="../classes/App.Clipboard.html">App.Clipboard</a></li>
            
                <li><a href="../classes/App.Prefs.html">App.Prefs</a></li>
            
                <li><a href="../classes/Chapter.html">Chapter</a></li>
            
                <li><a href="../classes/Collection.html">Collection</a></li>
            
                <li><a href="../classes/ColText.html">ColText</a></li>
            
                <li><a href="../classes/ContextualHelp.html">ContextualHelp</a></li>
            
                <li><a href="../classes/DICO.html">DICO</a></li>
            
                <li><a href="../classes/Fiche.html">Fiche</a></li>
            
                <li><a href="../classes/FICHES.html">FICHES</a></li>
            
                <li><a href="../classes/Film.html">Film</a></li>
            
                <li><a href="../classes/FILMS.html">FILMS</a></li>
            
                <li><a href="../classes/HTMLTable.html">HTMLTable</a></li>
            
                <li><a href="../classes/Mot.html">Mot</a></li>
            
                <li><a href="../classes/ObjetClass.html">ObjetClass</a></li>
            
                <li><a href="../classes/OBJETS.html">OBJETS</a></li>
            
                <li><a href="../classes/OBJETS.Dom.html">OBJETS.Dom</a></li>
            
                <li><a href="../classes/Page.html">Page</a></li>
            
                <li><a href="../classes/Paragraph.html">Paragraph</a></li>
            
                <li><a href="../classes/PARAGRAPHES.html">PARAGRAPHES</a></li>
            
                <li><a href="../classes/Ref.html">Ref</a></li>
            
                <li><a href="../classes/REFS.html">REFS</a></li>
            
                <li><a href="../classes/Search.html">Search</a></li>
            
                <li><a href="../classes/UI.html">UI</a></li>
            
                <li><a href="../classes/UI.Html.html">UI.Html</a></li>
            
                <li><a href="../classes/UI.Input.html">UI.Input</a></li>
            
                <li><a href="../classes/UI.ModeUnique.html">UI.ModeUnique</a></li>
            
                <li><a href="../classes/UI.Textarea.html">UI.Textarea</a></li>
            
                <li><a href="../classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/app.html">app</a></li>
            
                <li><a href="../modules/app

Objet qui gère le clipboard de l&#x27;application, dans lequel on peut mettre
des fiches, des références, etc..html">app

Objet qui gère le clipboard de l&#x27;application, dans lequel on peut mettre
des fiches, des références, etc.</a></li>
            
                <li><a href="../modules/app-prefs.html">app-prefs</a></li>
            
                <li><a href="../modules/App_clipboard.html">App_clipboard</a></li>
            
                <li><a href="../modules/Chapter.html">Chapter</a></li>
            
                <li><a href="../modules/Collection.html">Collection</a></li>
            
                <li><a href="../modules/ColText.html">ColText</a></li>
            
                <li><a href="../modules/ContextualHelp.html">ContextualHelp</a></li>
            
                <li><a href="../modules/data.html">data</a></li>
            
                <li><a href="../modules/Data.html">Data</a></li>
            
                <li><a href="../modules/Debug.html">Debug</a></li>
            
                <li><a href="../modules/DICO.html">DICO</a></li>
            
                <li><a href="../modules/DICO.js.html">DICO.js</a></li>
            
                <li><a href="../modules/Dom.html">Dom</a></li>
            
                <li><a href="../modules/dom.html">dom</a></li>
            
                <li><a href="../modules/Edition.html">Edition</a></li>
            
                <li><a href="../modules/edition.collection.js.html">edition.collection.js</a></li>
            
                <li><a href="../modules/Fiche.html">Fiche</a></li>
            
                <li><a href="../modules/fiche_data.html">fiche_data</a></li>
            
                <li><a href="../modules/fiche_dom.html">fiche_dom</a></li>
            
                <li><a href="../modules/FICHES.html">FICHES</a></li>
            
                <li><a href="../modules/FilmClass.html">FilmClass</a></li>
            
                <li><a href="../modules/FILMS.html">FILMS</a></li>
            
                <li><a href="../modules/Html.html">Html</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/jQueryExtension.html">jQueryExtension</a></li>
            
                <li><a href="../modules/KeyboardEvents.html">KeyboardEvents</a></li>
            
                <li><a href="../modules/KeyEvents.html">KeyEvents</a></li>
            
                <li><a href="../modules/Mot.html">Mot</a></li>
            
                <li><a href="../modules/OBJET.html">OBJET</a></li>
            
                <li><a href="../modules/ObjetClass.html">ObjetClass</a></li>
            
                <li><a href="../modules/objets.html">objets</a></li>
            
                <li><a href="../modules/OBJETS.Dom.html">OBJETS.Dom</a></li>
            
                <li><a href="../modules/Page.html">Page</a></li>
            
                <li><a href="../modules/Paragraph.html">Paragraph</a></li>
            
                <li><a href="../modules/PARAGRAPHS.html">PARAGRAPHS</a></li>
            
                <li><a href="../modules/ready.js.html">ready.js</a></li>
            
                <li><a href="../modules/ref.js.html">ref.js</a></li>
            
                <li><a href="../modules/REFS.js.html">REFS.js</a></li>
            
                <li><a href="../modules/Search.js.html">Search.js</a></li>
            
                <li><a href="../modules/String.html">String</a></li>
            
                <li><a href="../modules/UI.html">UI</a></li>
            
                <li><a href="../modules/UI_HTML.html">UI_HTML</a></li>
            
                <li><a href="../modules/ui_html_table

Le module définit l&#x27;objet UI.Html.str2table et la classe HTMLTable qui
permet de mettre en forme un tableau..html">ui_html_table

Le module définit l&#x27;objet UI.Html.str2table et la classe HTMLTable qui
permet de mettre en forme un tableau.</a></li>
            
                <li><a href="../modules/UI_Input.html">UI_Input</a></li>
            
                <li><a href="../modules/ui_mode_unique.html">ui_mode_unique</a></li>
            
                <li><a href="../modules/window.html">window</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: /Users/philippeperret/Sites/table_narration/js/required/Fiche_class.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
  * @module Fiche
  */

/**
  *  Class Fiche
  *  -----------
  *
  *  Toutes les instances Book, Page, Chapter et Paragraph héritent d&#x27;elle
  *
  *
  *  RAPPELS
  *  -------
  *    * C&#x27;est en ajoutant un enfant à une fiche qu&#x27;on détermine les propriétés
  *      &#x60;parent&#x27; et &#x60;enfants&#x27; des deux fiches concernant.
  *      cf. la méthode &quot;add_enfant&quot;.
  *
  * @class  Fiche
  *
  */
window.Fiche = function(data)
{
  dlog(&quot;---&gt; Fiche (instanciation)&quot;, DB_FCT_ENTER)
  
  this.class      = &quot;Fiche&quot;
  this.id         = null
  this.created_at = null
  this.type       = null      // le type, entre &#x27;book&#x27;, &#x27;page&#x27;, &#x27;chap&#x27;, &#x27;para&#x27;
  this.dev        = 0         // Niveau de développement
  
  // --- State ---
  // (ci-dessous les valeurs par défaut)
  this.loaded     = false   // Mis à true si elle est entièrement chargée
  this.deleted    = false
  this._opened    = false   // cf. propriété complexe &#x60;opened&#x27;
  /**
    * Indicateur d&#x27;édition
    * Cette propriété est mise à TRUE quand le texte (pour un paragraphe) ou
    * le titre (pour autre type de fiche) est en édition (input/textarea au lieu
    * de div)
    * @property {Boolean} edited
    * @default  False
    */
  this.edited     = false
  // this._ranged    = false   // cf. propriété complexe &#x60;ranged&#x27;
  this.selected   = false
  this.built      = false   // mis à true quand la fiche est construite
  this.retourned  = false   // Mis à true quand c&#x27;est le verso affiché
  this.draggable  = false
  this.sortable   = false
  if(undefined == data) data = {}
  
  // Nouvelle fiche ?
  // @note: Il faut le faire avant que ne soient dispatchées les valeurs,
  // car la définition de ces valeurs fait appel à d&#x27;autres méthodes qui
  // utilisent l&#x27;identifiant (par exemple les méthodes de type &#x60;_jid&#x27;)
  if(undefined == data.id || data.id == null) 
  {
    this.created_at = Time.now()
    this.id = ++ FICHES.last_id
    this.loaded = true
  }
  
  this.dispatch( data )
  
  FICHES.add( this )
  dlog(&quot;&lt;- Fiche (instanciation)&quot;, DB_FCT_ENTER)
  
}

Object.defineProperties(Fiche.prototype, {
  
  /* ---------------------------------------------------------------------
   *      DONNÉES DE LA FICHE
   --------------------------------------------------------------------- */
  /**
    *  Retourne un {Array} des minidata des enfants 
    *
    * @property enfants_as_minidata
    * @type     {Array}
    * @default  []
    *
    */
  &quot;enfants_as_minidata&quot;:{
    get:function(){
      arr = []
      for(var i in this.enfants){ 
        arr.push(this.enfants[i].minidata)
      }
      return arr
    }
  },

  /**
    * Return la fiche suivant la fiche courante
    * Si elle existe
    * @property {Fiche} next
    * @default  La fiche ou Null
    */
  &quot;next&quot;:{
    get:function(){
      if(!this.parent) return null
      return this.parent.enfants[this.indice + 1]
    }
  },
  /**
    * Return la fiche précédent la fiche courante
    * Si elle existe, ou Null
    * @property {Fiche} prev
    * @default la fiche ou Null
    */
  &quot;prev&quot;:{
    get:function(){
      if(!this.indice || !this.parent) return null
      return this.parent.enfants[this.indice - 1]
    }
  },
  /* ---------------------------------------------------------------------
   *      PROPRIÉTÉS D&#x27;ÉTAT
   --------------------------------------------------------------------- */
  &quot;modified&quot;:{
    set:function(val){
      if(val &amp;&amp; !this._modified)
      {
        if(val) Collection.add_modified( this ) ;
      }
      this._modified = val
    },
    get:function(){return this._modified || false }
  },
  
  /**
    * Marque la fiche ouverte ou fermée (ou retourne la propriété)
    * True si la fiche est ouverte, false dans le cas contraire.
    * Notes
    * -----
    *   * La propriété se contente d&#x27;ajouter ou de retirer la class &#x27;opened&#x27;
    *     à l&#x27;objet DOM de la fiche.
    *
    * @property {Boolean} opened
    * @default false
    */
  &quot;opened&quot;:{
    get:function(){ return this._opened || false },
    set:function(opened){
      this._opened = opened
      this.obj[opened?&#x27;addClass&#x27;:&#x27;removeClass&#x27;](&#x27;opened&#x27;)
    }
  },
  /**
    * Returne true si la fiche est fermée, false si ouverte
    *
    * @property {Boolean} closed
    * @default  true
    * @readOnly
    */
  &quot;closed&quot;:{get:function(){return this.opened == false}},
  
  /**
    * Marque l&#x27;élément rangé ou non rangé (ou retourne la propriété ranged)
    *
    * NOTES
    * -----
    *   * La valeur retournée dépend du type de fiche.
    *       * Pour un livre, la valeur est toujours false
    *       * Pour un chapitre ou un paragraphe, dès qu&#x27;ils ont un parent,
    *         ils sont toujours rangés.
    *       * Pour un page, dépend de son ouverture / fermeture.
    *
    * @property {Boolean} ranged
    */
  &quot;ranged&quot;:{
    get:function(){
      if(this.is_book) return false
      if(this.parent &amp;&amp; (this.is_chapter || this.is_paragraph)) return true
      if(this.is_page) return this.parent &amp;&amp; this.closed
    }
  },

  /* ---------------------------------------------------------------------
   */
  /**
    * Vérifie si la fiche peut être ouverte
    * Pour être ouverte, la fiche doit être &#x60;loaded&#x27; et ses enfants doivent
    * l&#x27;être aussi.
    *
    * NOTES
    * -----
    *   * Les enfants, dans la fiche, sont toujours des instances Fiche.
    *     (réglées au chargement du parent). C&#x27;est leur propriété &#x60;loaded&#x27;
    *     qui détermine si elles sont chargées ou non.
    *   * On peut appeler la méthode &#x60;rend_openable(&lt;poursuivre&gt;)&#x27; pour rendre
    *     la fiche ouvrable après le test &#x60;&lt;fiche&gt;.is_not_openable&#x27;
    *   * Propriété complexe =&gt; appeler sans parenthèses
    * @method is_openable
    * @return {Boolean} true si la fiche peut être ouverte, false otherwise.
    *
    */
  &quot;is_openable&quot;:{
    get:function(){
      dlog(&quot;-&gt; Fiche::is_openable [&quot;+this.type_id+&quot;]&quot;, DB_FCT_ENTER)
      var i = 0, ichild ;
      if(this.is_paragraph) return true ; // toujours ouvrable
      if(this.loaded == false) return false ;
      if(!this.enfants || this.enfants == []) return true ;
      for(len = this.enfants.length; i&lt;len; ++i)
      {
        ichild = this.enfants[i]
        if(false == (ichild.loaded &amp;&amp; ichild.built) ) return false
      }
      // Si on arrive ici, c&#x27;est que tous les éléments ont été chargés
      return true
    }
  },
  &quot;is_not_openable&quot;:{
    get:function(){return this.is_openable == false}
  },
    
  /**
    * Positionne la fiche sur le table en fonction de :
    * - son état ranged ou non
    * - ses top / left
    * Notes
    *   * Propriété complexe =&gt; appeler sans parenthèses
    * @method positionne
    */
  &quot;positionne&quot;:{
    get:function(){
      if( this.ranged || this.top == null || !this.obj ) return
      this.obj.css({&#x27;top&#x27;:this.top+&quot;px&quot;, &#x27;left&#x27;:this.left+&quot;px&quot;})
    }
  },
  
  /**
    * Création d&#x27;une nouvelle fiche
    * -----------------------------
    * 
    * NOTES
    * -----
    *   * Il ne suffit pas de créer la fiche pour qu&#x27;elle soit mise en 
    *     sauvegarde. Cela permet de les créer tranquillement lors du chargement
    *     de la collection.
    *     C&#x27;est seulement lorsqu&#x27;un élément de la fiche aura été modifié (et
    *     notamment le titre ou le texte — paragraph) qu&#x27;elle sera prête pour
    *     l&#x27;enregistrement.
    *
    * @property {Method} create
    */
  &quot;create&quot;:{
    get:function(){
      dlog(&quot;---&gt; Fiche::CREATE (&quot;+this.type_id+&quot;)&quot;, DB_FCT_ENTER)
      this.build
      this.set_values
      dlog(&quot;&lt;- Fiche::CREATE (&quot;+this.type_id+&quot;)&quot;, DB_FCT_ENTER)
      return true
    }
  },
  
  /*
   *  Construction de la fiche sur la table
   *  
   */
  &quot;build&quot;:{
    get:function(){
      var idm = &quot;Fiche::build [&quot;+this.type_id+&quot;]&quot; ;
      dlog(&quot;---&gt; &quot; + idm, DB_FCT_ENTER)
      // On ajoute le code ou on le remplace
      if(this.obj) this.obj.replaceWith( this.html )
      else         $(&#x27;section#table&#x27;).append( this.html )
      // On place les observers
      this.observe
      // On marque la fiche construite
      this.built = true
      dlog(&quot;&lt;- &quot; + idm, DB_FCT_ENTER)
      return true
    }
  },
  
  /*
   *  Place tous les OBSERVERS sur la fiche
   *  
   */
  &quot;observe&quot;:{
    get:function(){
      var idm = &quot;Fiche::observe [&quot;+this.type_id+&quot;]&quot; ;
      dlog(&quot;---&gt; &quot; + idm, DB_FCT_ENTER)
      var obj ;
      
      // Rend la fiche draggable
      this.rend_draggable
      
      // Rend ses enfants sortable
      this.div_items.sortable({
        // &#x27;containment&#x27; :&quot;fiche.&quot;+this.type+&quot; &gt; recto &gt; div.items&quot;,
        &#x27;axis&#x27;        :&quot;y&quot;,
        &#x27;helper&#x27;      :&quot;clone&quot;,
        &#x27;placeholder&#x27; :&#x27;newplace&#x27;,
        &#x27;update&#x27;      :$.proxy(this.onchange_ordre_enfants, this)
      })
      
      // Un click sur la fiche doit la sélectionner/déselectionner
      // Mais seulement en recto
      this.active_click_on_fiche

      // Le click sur la fiche, en combinaison avec des modifiers,
      // doit entrainer différents résultats (pour le moment, avec 
      // CMD, on met le titre/texte en édition)
      this.main_field.bind(&#x27;click&#x27;, $.proxy(FICHES.on_click_on_main_field, FICHES, this))

      if(this.is_book)
      {
        // La modification du titre réel doit entrainer son update
        // obj = this.input_real_titre
        // obj.bind(&#x27;focus&#x27;, $.proxy(FICHES.onfocus_textfield, FICHES, this))
        // obj.bind(&#x27;blur&#x27;, $.proxy(FICHES.onblur_textfield, FICHES, this))
        // this.input_real_titre[0].onchange = $.proxy(this.onchange_real_titre, this)
        UI.Input.bind( this.input_real_titre )
      }
      // Toutes les fiches hors paragraphes doivent être droppable et
      // accepter un élément de rang inférieur
      var accepted_child = FICHES.datatype[this.type].child_type
      if(this.is_not_paragraph)
      {
        this.obj.droppable({
          hoverClass  :&#x27;dropped&#x27;,
          tolerance   : &#x27;pointer&#x27;,
          greedy      : true, // pour empêcher de se propager à la table
          accept      : function(drags){
            // Pour empêcher la propagation
            if(drags.attr(&#x27;drg_time&#x27;))
            {
              return drags.attr(&#x27;drg_time&#x27;) == this.drg_time
            }
            if(drags.hasClass(&#x27;card_tool&#x27;)) return drags.attr(&#x27;data-type&#x27;)==accepted_child
            if(drags.hasClass(&#x27;fiche&#x27;)) return drags.hasClass(accepted_child)
            return false
          },
          drop        :$.proxy(this.on_drop, this),
          over        :function(evt,ui){
            ui.draggable.attr(&#x27;drg_time&#x27;, this.drg_time = evt.timeStamp)
          },
          out:function(evt,ui){
            // not required but cleaner
            ui.draggable.removeAttr(&#x27;drg_time&#x27;)
          }
        })
      }
      dlog(&quot;&lt;- &quot; + idm, DB_FCT_ENTER)
      return true
    }
  },
  &quot;active_click_on_fiche&quot;:{
    get:function(){
      // this.obj.bind(&#x27;click&#x27;, $.proxy(this.toggle_select, this))
      this.recto.bind(&#x27;click&#x27;, $.proxy(this.toggle_select, this))
      this.verso.bind(&#x27;click&#x27;, function(evt){evt.stopPropagation();return true})
    }
  },
  &quot;desactive_click_on_fiche&quot;:{
    get:function(){
      // this.obj.unbind(&#x27;click&#x27;, $.proxy(this.toggle_select, this))
      this.recto.unbind(&#x27;click&#x27;, $.proxy(this.toggle_select, this))
    }
  },
  /*
   *  Rend la fiche sortable (lorsqu&#x27;elle est rangée)
   *  
   */
  &quot;rend_sortable&quot;:{
    get:function(){
      // this.div_items.sortable()
      this.sortable = true
    }
  },
  /*
   *  Rend la fiche draggable (lorsqu&#x27;elle est posée sur la table)
   *  
   */
  &quot;rend_draggable&quot;:{
    get:function(){
      var idm = &quot;Fiche::rend_draggable (&quot;+this.type_id+&quot;)&quot;
      dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER)
      this.obj.draggable({
        containment:&#x27;parent&#x27;,
        stop: $.proxy(this.stop_drag, this)
      })
      this.draggable = true
      dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER)
    }
  },

  /*
   *  Rend la fiche &quot;ouvrable&quot;
   *  (en chargeant ses données au besoin et ses enfants)
   *  
   *  @param  poursuivre    SOIT une fonction pour poursuivre, 
   *                        SOIT un {String} qui sera une pseudo-méthode (propriété
   *                        complexe) de la fiche elle-même.
   *                        SOIT un {Object} contenant :
   *                        {id:&lt;id de la fiche&gt;, prop:&lt;propriété complexe&gt;}
   */
  &quot;rend_openable&quot;:{
    value:function(poursuivre){
      var idm = &quot;Fiche::rend_openable [&quot;+this.type_id+&quot;]&quot; 
      dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER)
      if(&#x27;string&#x27; == typeof poursuivre) poursuivre = {id:this.id, prop:poursuivre}
      FICHES.after_load.poursuivre = poursuivre
      FICHES.load( this.enfants_as_minidata )
      dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER)
    }
  },
  
  /*
   *  Toggle (ouvre/ferme) la fiche
   *  
   */
  &quot;toggle&quot;:{
    get:function(){
      this.opened ? this.close : this.open
    }
  },
  
  
  /*
   *  Destruction totale d&#x27;une fiche
   *  
   */
  &quot;remove&quot;:{
    configurable:true,
    get:function(){
      this.obj.remove()
      this.delete ;
    }
  },
  
  /*
   *  Volonté de supprimer la fiche (confirmation)
   *
   *  Si la confirmation est demandée, la méthode &quot;delete&quot; est vraiment appelée  
   */
  &quot;want_delete&quot;:{
    get:function(){
      Edit.show({
        id:&#x27;kill_fiche&#x27;,
        title: LOCALE.fiche[&#x27;want delete fiche&#x27;],
        fields:{
          kill_children:{type:&#x27;checkbox&#x27;, value:&quot;true&quot;, libelle:LOCALE.fiche[&#x27;kill children&#x27;], checked:false}
        },
        buttons:{
          cancel:{name:&quot;Renoncer&quot;},
          ok:{name:&quot;Détruire la fiche&quot;, onclick:$.proxy(FICHES.remove, FICHES, this)}
        }
      })
    }
  },
  /*
   *  Suppression d&#x27;une fiche
   *  
   *  NOTE: CETTE PROPRIÉTÉ NE DOIT PAS ÊTRE APPELÉE
   *        Il faut appeler &lt;fiche&gt;.want_delete (qui appelle ensuite FICHES.remove)
   */
  &quot;delete&quot;:{
    get:function(){
      this.deleted  = true
      this.modified = true
      this.obj.remove()
    }
  },
  
  /* ---------------------------------------------------------------------
   *  MÉTHODES POUR COPIER/COUPER/COLLER LES ENFANTS
   --------------------------------------------------------------------- */
  /**
    * Copie la fiche
    * Notes
    *   * En réalité, la &quot;copie&quot; de la fiche ne consiste qu&#x27;à mettre sa référence
    *     dans App.Clipboard
    *   * On reconnait une fiche coupée d&#x27;une fiche copiée au &#x27;cuted&#x27; qui est 
    *     ajouté quand on coupe la fiche.
    * @property {Method} copy
    */
  &quot;copy&quot;:{
    get:function(){
      App.Clipboard.add(this)
      F.show(LOCALE.fiche[&#x27;copy or paste&#x27;].templatize({type:this.human_type, action:&#x27;copiée&#x27;}))
    }
  },
  /**
    * Coupe la fiche
    * Notes
    *   * En réalité, la &quot;coupe&quot; de la fiche ne consiste qu&#x27;à mettre son instance
    *     dans App.Clipboard.content.fiche en mettant son cuted à true et en masquant 
    *     son objet dans le DOM (pour ne pas avoir à le reconstruire.)
    *
    * @property {Method} cut
    */
  &quot;cut&quot;:{
    get:function(){
      App.Clipboard.add( this )
      this.obj.hide()
      F.show(LOCALE.fiche[&#x27;copy or paste&#x27;].templatize({type:this.human_type, action:&#x27;coupée&#x27;})+
      &quot;\nNoter que tant que la fiche n&#x27;a pas été collée, elle n&#x27;est pas retirée du parent courant.&quot;)
    }
  },
  /**
    * Colle la fiche
    * Notes
    *   * Pour coller la fiche copiée/coupée, il faut qu&#x27;un parent ou un frère
    *     potentiel soit sélectionné. Si c&#x27;est un parent, on ajoute la fiche à la
    *     fin. Sinon, on l&#x27;ajoute avant le parent sélectionné.
    *   * Si la fiche avait été copiée, il faut reconstruire une fiche de toute pièce
    *     en se servant des informations de la fiche copiée. Si au contraire la fiche
    *     a été coupée, il faut la sortir de son parent et la remettre dans le nouveau.
    *
    * TODO: Pour le moment, on ne peut pas coller une fiche sur la table, mais on
    * devrait pouvoir le faire.
    *
    * @property {Method} paste
    */
  &quot;paste&quot;:{
    get:function(){
      try
      {
        clip = App.Clipboard.get(&#x27;fiche&#x27;)
        
        if(!clip) throw &#x27;no copied fiche&#x27;
        if(clip.type != this.child_type &amp;&amp; clip.type != this.type) 
          throw &#x27;bad child type in clipboard&#x27;
        if(clip.type == this.type){
          if(!this.parent) throw &#x27;no parent for clipboarded fiche&#x27;
          if(clip.cuted &amp;&amp; clip.parent == this.parent)
            throw &#x27;clipboarded fiche already in parent&#x27;
        }
        else if (clip.type == this.child_type){
          if(clip.cuted &amp;&amp; clip.parent == this)
            throw &#x27;clipboarded fiche already in parent&#x27;
        }
          
      }
      catch(err_id){return F.error(LOCALE.fiche.error[err_id])}

      // === La fiche peut être collée ===
      // @note : si elle appartient à un parent, il faut la retirer de ce parent.
      // - Si la fiche est &quot;not cuted&quot;, il faut créer une autre fiche d&#x27;après
      //   les données de la fiche copiée (et remettre le copied de la fiche à false)
      // - Si la fiche est &#x27;cuted=true&#x27;, il faut 1/ la sortir de son parent, 2/
      //    l&#x27;injecter dans le parent courant et 3/ remettre son obj à display=block
      //    pour le faire ré-apparaitre
      var new_parent, beforeChild ;
      if(clip.type == this.child_type)
      {
        // La fiche sélectionnée (courante) est le nouveau parent de la fiche
        // Il faut placer la fiche copiée/coupée au bout du parent
        new_parent = this
      }
      else
      {
        // La fiche sélectionnée est le nouveau frère (cadet) de la fiche
        // copiée/coupée
        new_parent  = this.parent
        beforeChild = this
      }

      if(clip.cuted) // Fiche coupée
      {
        clip.parent.remove_child( clip )
      }
      else
      {
        // Fiche copiée =&gt; la cloner
        var data = {}
        var props = [ // mettre ici les propriétés à cloner
          &#x27;type&#x27;
          ]
        switch(clip.type)
        {
        case &#x27;book&#x27;:
          props.push(&#x27;real_titre&#x27;)
          break
        case &#x27;para&#x27;:
          props.push(&#x27;texte&#x27;)
          props.push(&#x27;ptype&#x27;)
        }
        if(clip.type!=&#x27;para&#x27;) props.push(&#x27;titre&#x27;)
        L(props).each(function(prop){ data[prop] = clip[prop]})
        fiche = FICHES.full_create(data)
        fiche.modified = true
      }
      
      // Si la fiche est pastée dans un parent (sinon, elle reste sur la table)
      if(new_parent)
      {
        new_parent.add_child( fiche, {before:beforeChild})
        if(fiche.cuted)
        {
          fiche.obj.show()
          delete fiche.cuted
        } 
      }
      
      // À la fin, il faut détruire le clipboard
      App.Clipboard.flush(&#x27;fiche&#x27;)
      Flash.clean()
    }
  }
  
})

/**
  * Appelé quand on relâche un enfant sur la fiche courante
  *  
  * @method on_drop
  * @param   {Event} evt   L&#x27;évènement drop
  * @param   {jQuerySet} ui    
  *          L&#x27;objet déplacé (ui.element est l&#x27;original)
  *               Note : l&#x27;original peut être soit une fiche réelle, soit
  *               un card-tool. Lorsque c&#x27;est une card-tool, il faut créer la
  *               nouvelle fiche.
  */
Fiche.prototype.on_drop = function(evt, ui)
{
  stop_event(evt)
  var idm = &quot;Fiche::on_drop [&quot;+this.type_id+&quot;]&quot;
  dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER | DB_CURRENT )
  UI.drop_on_fiche = true
  
  var obj_moved = ui.draggable
  var ichild
  var is_tool   = obj_moved.hasClass(&#x27;card_tool&#x27;) ;
  
  if(is_tool)
  {
    // On crée la fiche
    var data = {
      type: obj_moved.attr(&#x27;data-type&#x27;),
      left: 100, top: 100
    }
    var dtype = FICHES.datatype[data.type]
    data[data.type == &#x27;para&#x27; ? &#x27;texte&#x27; : &#x27;titre&#x27;] = dtype.defvalue
    
    // L&#x27;attribut drg_time reste parfois dans l&#x27;outil, ce qui empêche ensuite
    // de le dragguer sur un parent. On supprime toujours cette attribut ici
    obj_moved.removeAttr(&#x27;drg_time&#x27;)
    
    // On crée entièrement la fiche
    ichild = FICHES.full_create(data)
  }
  else
  {
    ichild = FICHES.domObj_to_fiche( obj_moved )
  }
  this.add_child( ichild )
  
  // Si cette fiche parent est fermée, il faut l&#x27;ouvrir
  if(false == this.opened) this.open
  
  // TODO: Plus tard, on pourra regarder si la fiche a été déposé à un
  // endroit précis, pour le placer au bon endroit dans les enfants
  // F.error(&quot;La méthode Fiche.on_drop doit être implémentée&quot;+
  // &quot;\nÉlément #&quot;+obj_moved.attr(&#x27;id&#x27;)+&quot; (outil ? &quot;+is_tool+&quot;) glissé sur fiche #&quot;+this.id)
  
  // Si c&#x27;est une création, on met aussi l&#x27;enfant en édition
  if(is_tool) ichild.enable_main_field
  
  return stop_event( evt )
}

$.extend(Fiche.prototype,{
  
  /**
    * Appelé quand on change l&#x27;ordre des enfants de la fiche, soit par le
    * sortable du div_items, soit par &#x60;move_up&#x60; ou &#x60;move_down&#x60; d&#x27;un des
    * enfant.
    *
    * NOTES
    * -----
    *   * Plutôt que de s&#x27;embêter à étudier +ui+ pour savoir quel
    *     élément a été déplacé, on compare la liste du DOM avec la liste des
    *     enfants et on commence à traiter à partir de cet indice.
    *   * Les deux arguments ne sont pas définis lorsque la méthode est appelée
    *     depuis &#x60;move_up&#x60; et &#x60;move_down&#x60;.
    *
    * @method onchange_ordre_enfants
    * @param  evt {Event}   UpdateEvent généré par sortable
    * @param  ui  {Object}  L&#x27;objet envoyé par jquery
    *
    */
  onchange_ordre_enfants:function(evt, ui)
  {
    stop_save
    dlog(&quot;onchange_ordre_enfants sur la fiche &quot;+this.type_id + &quot; : &quot; + this.titre)
    var sorted_id, sorted_ids = 
      L(this.div_items.sortable(&#x27;toArray&#x27;)).
      collect(function(domid){ return parseInt(domid.split(&#x27;-&#x27;)[1],10)})
    
    this.enfants = []
    while(sorted_id = sorted_ids.shift()) this.enfants.push(get_fiche(sorted_id))
    this.update_indice_enfants()
    this.modified = true
    restart_save
  },
  
  /*
    * Actualise l&#x27;indice des enfants à partir de +from+
    *
    * NOTES
    * -----
    *   * L&#x27;indice des enfants (0-start) est une propriété volatile
    *     utile à quelques méthodes, par exemple l&#x27;insertion d&#x27;enfants
    *     à un endroit précis.
    *
    * @method update_indice_enfants
    * @param [from=0] {Number} from  Indice de départ
    */
  update_indice_enfants:function(from)
  {
    if(undefined == from) from = 0
    for(var ichild = from, len=this.enfants.length; ichild&lt;len; ++ichild)
    {
      this.enfants[ichild].indice = parseInt(ichild, 10)
    }
  },
  
  /**
    * Ajout d&#x27;un enfant à la fiche
    *
    * NOTES
    * -----
    *   * C&#x27;est cette méthode qui doit être utilisée pour tout ajout
    *     d&#x27;enfant.
    *
    * @method add_child
    * @param  enfant    {Fiche} de l&#x27;enfant à ajouter
    * @param  options   {Object} Options d&#x27;insertion :
    *   @param  {Fiche} options.after  Ajouter après cet enfant
    *   @param  {Fiche} options.before Ajouter avant cet enfant
    */
  add_child:function(enfant, options)
  {
    var idm = &quot;Fiche::add_child(&quot;+enfant.type+&quot;:&quot;+enfant.id+&quot;) [&quot;+this.type_id+&quot;]&quot;
    dlog(&quot;-&gt; &quot;+idm, DB_FCT_ENTER | DB_CURRENT)
    if(undefined == options) options = {}
    try
    {
      if(!enfant || &#x27;object&#x27;!=typeof enfant)  throw &#x27;child should be an object&#x27;
      if( enfant.class != &#x27;Fiche&#x27;)            throw &#x27;child should be a fiche&#x27;
      thislevel = FICHES.datatype[this.type].level ;
      chillevel = FICHES.datatype[enfant.type].level ;
      if( thislevel &lt;= chillevel )            throw &#x27;child bad type&#x27;
    }
    catch(err){throw LOCALE.fiche.error[err]}
  
    // Ajout de l&#x27;enfant à la liste
    if(this.enfants == null)
    {
      enfant.indice = 0
      this.enfants  = [enfant]
    } 
    else
    {
      if(options.after || options.before){
        var indice = options.after ? options.after.indice + 1 : options.before.indice
        this.enfants.splice(indice, 0, enfant)
        this.update_indice_enfants(from = indice)
      }
      else {
        enfant.indice = this.enfants.length
        this.enfants.push( enfant )
      }
    }
  
    // Définition du parent de l&#x27;enfant
    enfant.parent = this
  
    if(enfant.opened) enfant.close
  
    /*
     *  Placement de l&#x27;objet DOM
     *  
     */
    if(options.after)
    { 
      enfant.obj.insertAfter( options.after.obj )
    }
    else if(options.before)
    { // =&gt; Ajout avant l&#x27;enfant before_child
      enfant.obj.insertBefore( options.before.obj )
    }
    else {
      this.div_items.append( enfant.obj )
    }
  
  
    this.modified   = true
    enfant.ranged   = true
    enfant.obj.addClass(&#x27;ranged&#x27;)
    enfant.modified = true
    
  },
  
  /**
    *  Supprime un enfant de la fiche
    *  
    * @method remove_child
    * @param  {Fiche} enfant  L&#x27;enfant à retirer.
    *
    */
  remove_child:function(enfant)
  {
    try
    {
      // L&#x27;enfant doit être du bon type
      if(&#x27;object&#x27; != typeof enfant || enfant.class != &#x27;Fiche&#x27;) throw &#x27;child should be a fiche&#x27;;

      // On va vérifier que l&#x27;enfant soit bien celui qu&#x27;il prétend être
      if(enfant.parent != this) throw &#x27;is not child&#x27;
      var childcheck = this.enfants[enfant.indice]
      if(childcheck != enfant) throw &#x27;is not child&#x27;
    }
    catch(err){ throw LOCALE.fiche.error[err] }
  
    this.enfants.splice(enfant.indice, 1)
    enfant._parent = null

    this.modified   = true
    enfant.modified = true

    // Actualisation de l&#x27;indice des enfants suivants
    this.update_indice_enfants(from = enfant.indice)
    
    // On peut retirer l&#x27;enfant de la liste
    if(enfant.ranged == false) enfant.range
    $(&#x27;section#table&#x27;).append( enfant.obj )
    enfant.positionne
    
  },
  
  /**
    * Méthode appelée quand on change le texte (paragraphe) ou le titre (autres
    * fiches) d&#x27;une fiche.
    *
    * NOTES
    * -----
    *   * La méthode interdit d&#x27;enregistrer une donnée vide.
    *   * Cela peut se produire lorsqu&#x27;on quitte le champ, ou lorsque
    *     l&#x27;on presse la touche RETURN sur le champ.
    *   * C&#x27;est vraiment cette fonction qui inaugure le changement du
    *     titre, car si c&#x27;était &#x60;titre=&#x60; (propriété complexe), on aura
    *     une difficulté à la définition des fiches remontées.
    *   * Les méthodes &#x60;onchange_titre&#x60; et &#x60;onchange_texte&#x60; ont été 
    *     différentiées car le traitement est très différent pour un texte.
    *
    * @method onchange_titre_or_texte
    * @param  {Event} evt   L&#x27;Onchange Event.
    *
    * @return {True} si la donnée a été prise en compte, {False} dans le cas contraire.
    */
  onchange_titre_or_texte:function(evt)
  {
    var idm = &quot;Fiche::onchange_titre_or_texte [&quot;+this.type_id+&quot;]&quot;
    dlog(&quot;---&gt; &quot;+idm, DB_FCT_ENTER)
    var obj=this.main_field, prop=this.main_prop ;
    var new_value = obj.val().trim()
    if(new_value == &quot;&quot;) return F.error(LOCALE.fiche.error[&#x27;no empty text&#x27;])
    if(this.is_paragraph)   this.onchange_texte(new_value)
                      else  this.onchange_titre(new_value)
    dlog(&quot;&lt;- &quot;+idm, DB_FCT_ENTER)
    return true
  },
  
  /**
    * Procède au change de titre de la fiche (tout type sauf paragraphe)
    * @method onchange_titre
    * @param  {String}  new_value   La nouvelle valeur à donner au titre
    */
  onchange_titre:function(new_value){
    if(this.titre != new_value)
    {
      this.titre    = new_value
      this.modified = true    
    }
    if(this.is_chapter) this.close
  }
  
})


/**
  * Invoquée à la fin du drag d&#x27;une fiche, cette méthode enregistre la nouvelle
  * position de la fiche, la place sur la grille si les préférences l&#x27;exigent et
  * indique que la fiche a été modifiée.
  *  
  * Notes
  * -----
  *   * C&#x27;est la préférence &#x60;App.preferences.snap&#x60; qui détermine s&#x27;il faut placer
  *     la fiche sur la grille (true par défaut)
  *
  * @method stop_drag
  * @param  {Event} evt DragStopEvent déclenché.
  * @param  {jQuery.ui} L&#x27;objet jQuery ayant déclenché le drag.
  *
  */
Fiche.prototype.stop_drag = function(evt, ui){
  var pos = this.obj.position()
  dlog(&quot;-&gt; Fiche::stop_drag&quot;, DB_FCT_ENTER)
  pos_on_grid = UI.position_on_grid([pos.left, pos.top], App.preferences.snap)
  this.left = pos_on_grid.left
  this.top  = pos_on_grid.top
  this.positionne
  this.modified = true
  // return stop_event(evt) // Car ça interromprait la procédure
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
